---
title: "Compound channel hydraulic flume with two longitudinal friction"
author: "Felipe"
date: "`r Sys.Date()`"
output: html_document
bibliography: biblio.bib
---

# Estimation: constant in the main channel and fourth degree in the floodplain (n_kmin = 0 and n_kflood = 4)


```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = FALSE
)
```
# Experimental set up

A compound channel setup was used for this case study. The paper including all information about the experience was found in [@dupuis_compound_2017](https://doi.org/10.1007/s10652-017-9525-0).

  - Length: 18 m
  - Width: 3 m
  - Slope: 0.00105
  - Main channel: 1 m wide rectangular glass bed
  - Floodplain: two 1 m wide rectangular configuration. Both floodplains were covered either by plastic grass alone (meadow) or by an array of emergent cylinders set on the plastic grass (wood).
  - Vertical distance from the main channel to the floodplain: 0.115 m
  - Flow conditions: uniform flow with a total discharge of 162 L/s, varying the discharge in the floodplain of 12 and 18 L/s.
  -  Water level measurements: the measures were taken spatial distributed from 2 m to 17 m.

```{r}
knitr::include_graphics("/home/famendezrios/Documents/These/VSCODE-R/HydroBayes/HydroBayes_git/Case_studies/HHLab/Compound_channel_spatial_friction/Cross_section_compound_channel.png")

knitr::include_graphics("/home/famendezrios/Documents/These/VSCODE-R/HydroBayes/HydroBayes_git/Case_studies/HHLab/Compound_channel_spatial_friction/longitudinal_compound_channel.png")
```

```{r load-packages, message = FALSE, include= FALSE}
library(RBaM)
library(patchwork)
library(ggplot2)
library(dplyr)
library(tidyr)
```

# Objectives and remarks of the case study

- Test the estimation when the friction in the floodplain changes suddenly in longitudinal direction
- Estimate a constant friction in the main channel and a linear combination in the floodplain 

# Calibration data

The selected case was a transition from wood to grass. WSE measurements were taken in the main channel and the floodplain at different positions. To compare with the simulations, a single value of WSE was calculated for each position by averaging the WSE values. Then the standard devaition was estimated using all the values for estimating a regression with `lm` function.

```{r}
path <- "/home/famendezrios/Documents/These/VSCODE-R/HydroBayes/HydroBayes_git/Case_studies/HHLab/Compound_channel_spatial_friction/Calibration/n_min_0_n_flood_2/"

load("/home/famendezrios/Documents/These/VSCODE-R/HydroBayes/HydroBayes_git/data/processed_data/HHLab/compound_transition_friction/data_HHLab_uniform_case.RData")

WSE_data_temp <- all_data_calibration$WSE

WSE_data_temp <- data.frame(WSE_data_temp %>%
  group_by(ID_experiment, x, z_riverbed) %>%
  summarise(
    z_mean_all = mean(z_mean),
    Yu_mean_all = mean(Yu), .groups = "drop"
  ))

case <- "CWMQ"
WSE_data <- WSE_data_temp[str_detect(WSE_data_temp$ID_experiment, pattern = case), ]


Cal_measures <- list(
  CWMQ18 = c(2.225, 4.310, 5.270, 6.240, 8.315, 9.115, 9.250, 10.250, 11.250, 12.250, 13.250),
  CWMQ12 = c(2.225, 2.975, 3.345, 4.095, 5.060, 6.240, 6.990, 8.030, 8.795, 9.065, 9.115, 9.545, 10.030, 11.370, 12.120, 12.325, 13.290)
)

CalData_sample <- c()
for (i in 1:length(Cal_measures)) {
  if (i == 1) {
    CalData_sample <- WSE_data[WSE_data$ID_experiment %in% names(Cal_measures)[i] &
      WSE_data$x %in% Cal_measures[[i]], ]
  } else {
    CalData_sample <- rbind(
      CalData_sample,
      WSE_data[WSE_data$ID_experiment %in% names(Cal_measures)[i] &
        WSE_data$x %in% Cal_measures[[i]], ]
    )
  }
}

CalData_sample[, -c(1, 2)] <- CalData_sample[, -c(1, 2)] * 1000
# Read calibration data and summary
getCalData <- read.table(
  file = file.path(path, "CalibrationData.txt"),
  header = TRUE,
  stringsAsFactors = FALSE
)
knitr::kable(getCalData,
  align = "c"
)
getCalData[, c("WSE", "Yu_z")] <- getCalData[, c("WSE", "Yu_z")] * 1000

ggplot() +
  geom_point(data = getCalData, aes(
    x = x, y = WSE, col = "obs"
  )) +
  geom_errorbar(data = getCalData, aes(
    x = x, y = WSE,
    ymin = WSE - Yu_z, ymax = WSE + Yu_z, col = "obs"
  )) +
  geom_line(
    data = CalData_sample,
    aes(x = x, y = z_riverbed, col = "river bed")
  ) +
  labs(
    title = "WSE observations",
    x = "Lengthwise position (meters)",
    y = "Water level elevation (mm)",
    color = NULL
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.title = element_text(hjust = 0.5)
  )
```

# Estimation with a standard deviation of 22 mm for WSE observations

## Check MCMC 
```{r}
path <- "/home/famendezrios/Documents/These/VSCODE-R/HydroBayes/HydroBayes_git/Case_studies/HHLab/Compound_channel_spatial_friction/Calibration/n_min_0_n_moy_4"

mcmc <- read.table(
  file = file.path(path, "Results_MCMC.txt"),
  header = TRUE,
  stringsAsFactors = FALSE
)

# Trace plot for each parameter
mcmc <- readMCMC(file.path(path, "Results_MCMC.txt"))
plots <- tracePlot(mcmc)

wrap_plots(plots, ncol = 3)

# Density plot for each parameter
plots <- densityPlot(mcmc)
wrap_plots(plots, ncol = 3)
```

### Partial conclusions:

Instabilities have been detected. However, the reduction of the uncertainty on the observations could reduce instabilites. 

## Check summary

```{r}
getSummary <- read.table(
  file = file.path(path, "Results_Summary.txt"),
  header = TRUE,
  stringsAsFactors = FALSE
)

# Values of error model in meter for WSE, in m3/s for discharge and m/s for velocity.
knitr::kable(getSummary,
  align = "c"
)

# Zoom into the MAP and standard deviation of the error model
getSummary_zoom <- getSummary[c(11, 16), ]
indx_ZQ <- which(colnames(getSummary_zoom) %in% c("Y1_intercept", "Y2_intercept"))
indx_V <- which(colnames(getSummary_zoom) %in% c("Y3_intercept"))
getSummary_zoom[, indx_ZQ] <- getSummary_zoom[, indx_ZQ] * 1000 # Convert to mm for WSE and discharge
getSummary_zoom[, indx_V] <- getSummary_zoom[, indx_V] * 100 # Convert to cm/s for velocity
knitr::kable(getSummary_zoom,
  align = "c",
  caption = "Zoom into the MAP and standard deviation of the error model: WSE in mm, discharge in L/s and velocity in mm/s."
)
```

## Check spatial friction distribution

```{r}
n_degree <- 0
n_degree_flood <- 4
ks_literature <- data.frame(min = 1 / 0.013, max = 1 / 0.009, mean = 1 / 0.010)

# Get MAP simulation
MAP_param_matrix <- as.numeric(getSummary_zoom[2, c(1:(n_degree + 1 + n_degree_flood + 1))])

matrix_zFileKmin <- read.table(file.path(path, "Zfile_Kmin.txt"), header = TRUE)

position <- read.table(file.path(path, "vector_legendre.txt"), header = TRUE)

k_estimated_all <- as.data.frame(as.matrix(matrix_zFileKmin) %*% as.matrix(t(mcmc[, 1:(n_degree + 1)])))

k_estimated_all$KP <- position[, 2]

# Convert to long format
df_MCMC_sampling <- pivot_longer(
  k_estimated_all,
  cols = -KP,
  values_to = "Value"
) %>%
  select(KP, Value) %>%
  mutate(ID = "MCMC Sampling")

k_estimated_MAP <- as.matrix(matrix_zFileKmin) %*% MAP_param_matrix[1:(n_degree + 1)]

df_MAP <- data.frame(
  KP = position[, 2],
  Value = k_estimated_MAP,
  ID = "MAP"
)

# Get 95% uncertainty for envelope curve : create ribbon data from MCMC
df_envelope <- df_MCMC_sampling %>%
  filter(ID == "MCMC Sampling") %>%
  group_by(KP) %>%
  summarise(
    ymin = quantile(Value, probs = 0.025, na.rm = TRUE),
    ymax = quantile(Value, probs = 0.975, na.rm = TRUE),
    ID = "Parametric\nuncertainty", # so we can map to fill
    .groups = "drop"
  )

ggplot() +
  geom_ribbon(
    data = df_envelope,
    aes(x = KP, ymin = ymin, ymax = ymax, fill = ID)
  ) +
  geom_line(
    data = df_MAP,
    aes(x = KP, y = Value, color = ID)
  ) +
  geom_hline(aes(yintercept = ks_literature$min, linetype = "ASCI (1980)"), color = "gray") +
  geom_hline(aes(yintercept = ks_literature$max, linetype = "ASCI (1980)"), color = "gray") +
  geom_hline(aes(yintercept = ks_literature$mean, linetype = "ASCI (1980)"), color = "gray") +
  scale_fill_manual(values = c("Parametric\nuncertainty" = "pink")) +
  scale_color_manual(values = c("MAP" = "black")) +
  # Échelle de type de ligne
  scale_linetype_manual(
    name = "Reference\nvalues",
    values = c("ASCI (1980)" = "dashed")
  ) +
  labs(
    title = "Friction coefficient estimation in the main channel \nwith parametric uncertainty",
    x = "Lengthwise position (meters)",
    y = expression("Friction coefficient (m"^
      {
        1 / 3
      } * "/s)"),
    fill = "95% credibility\ninterval",
    color = NULL
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.title = element_text(hjust = 0.5)
  )
```

```{r}
# floodplain

matrix_zFileKflood <- read.table(file.path(path, "Zfile_Kflood.txt"), header = TRUE)

k_estimated_all_floodplain <- as.data.frame(as.matrix(matrix_zFileKflood) %*% as.matrix(t(mcmc[, (n_degree + 1 + 1):(n_degree + 1 + n_degree_flood + 1)])))

k_estimated_all_floodplain$KP <- position[, 2]

# Convert to long format
df_MCMC_sampling <- pivot_longer(
  k_estimated_all_floodplain,
  cols = -KP,
  values_to = "Value"
) %>%
  select(KP, Value) %>%
  mutate(ID = "MCMC Sampling")

k_estimated_MAP <- as.matrix(matrix_zFileKflood) %*% MAP_param_matrix[(n_degree + 1 + 1):(n_degree + 1 + n_degree_flood + 1)]

df_MAP <- data.frame(
  KP = position[, 2],
  Value = k_estimated_MAP,
  ID = "MAP"
)

# Get 95% uncertainty for envelope curve : create ribbon data from MCMC
df_envelope <- df_MCMC_sampling %>%
  filter(ID == "MCMC Sampling") %>%
  group_by(KP) %>%
  summarise(
    ymin = quantile(Value, probs = 0.025, na.rm = TRUE),
    ymax = quantile(Value, probs = 0.975, na.rm = TRUE),
    ID = "Parametric\nuncertainty", # so we can map to fill
    .groups = "drop"
  )

ggplot() +
  geom_ribbon(
    data = df_envelope,
    aes(x = KP, ymin = ymin, ymax = ymax, fill = ID)
  ) +
  geom_line(
    data = df_MAP,
    aes(x = KP, y = Value, color = ID)
  ) +
  geom_segment(aes(x = 0, xend = 9.05, y = ks_literature_floodplain_wood$min, yend = ks_literature_floodplain_wood$min, linetype = "Chow (1959)", color = "gray")) +
  geom_segment(aes(x = 0, xend = 9.05, y = ks_literature_floodplain_wood$max, yend = ks_literature_floodplain_wood$max, linetype = "Chow (1959)", color = "gray")) +
  geom_segment(aes(x = 0, xend = 9.05, y = ks_literature_floodplain_wood$mean, yend = ks_literature_floodplain_wood$mean, linetype = "Chow (1959)", color = "gray")) +
  geom_segment(aes(x = 9.05, xend = 18, y = ks_literature_floodplain_grass$min, yend = ks_literature_floodplain_grass$min, linetype = "Chow (1959)", color = "gray")) +
  geom_segment(aes(x = 9.05, xend = 18, y = ks_literature_floodplain_grass$max, yend = ks_literature_floodplain_grass$max, linetype = "Chow (1959)", color = "gray")) +
  geom_segment(aes(x = 9.05, xend = 18, y = ks_literature_floodplain_grass$mean, yend = ks_literature_floodplain_grass$mean, linetype = "Chow (1959)", color = "gray")) +
  scale_fill_manual(values = c("Parametric\nuncertainty" = "pink")) +
  scale_color_manual(values = c("MAP" = "black")) +
  # Échelle de type de ligne
  scale_linetype_manual(
    name = "Reference\nvalues",
    values = c("Chow (1959)" = "dashed")
  ) +
  labs(
    title = "Friction coefficient estimation in the floodplain \nwith parametric uncertainty",
    x = "Lengthwise position (meters)",
    y = expression("Friction coefficient (m"^
      {
        1 / 3
      } * "/s)"),
    fill = "95% credibility\ninterval",
    color = NULL
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.title = element_text(hjust = 0.5)
  )
```

### Partial conclusions:

Results are not very satisfatory and a point to highlight is the boundaries problem instrinsic to the Legendre polynomial method.

## Check of residuals

```{r}
# Read residuals
residuals <- read.table(
  file = file.path(path, "Results_Residuals.txt"),
  header = TRUE,
  stringsAsFactors = FALSE
)

# Replace -9999 and -1e9 with NA
residuals[residuals == -9999] <- NA
residuals[residuals == -1e9] <- NA

# Convert residuals to mm and m3/s
residuals_mm_m3_s <- data.frame(
  residuals[, 1:4],
  residuals[, c(9, 19, 20, 24, 29)] * 1000
)


getCalData <- read.table(
  file = file.path(path, "CalibrationData.txt"),
  header = TRUE,
  stringsAsFactors = FALSE
)
knitr::kable(getCalData,
  align = "c"
)
getCalData[, c("WSE", "Yu_z")] <- getCalData[, c("WSE", "Yu_z")] * 1000

residuals_event_mm_m3_s <- data.frame(residuals_mm_m3_s, Yu_z = getCalData[, "Yu_z"])

# Plot WSE residuals
ggplot(residuals_event_mm_m3_s, aes(x = X3_obs)) +
  geom_point(aes(y = Y1_sim, col = "sim")) +
  labs(title = "MAP simulations vs Observations (WSE)", x = "Position (m)", y = "Water surface elevation (mm)") +
  geom_point(aes(y = Y1_obs, col = "obs")) +
  geom_errorbar(aes(
    ymin = Y1_obs - 1.96 * Yu_z,
    ymax = Y1_obs + 1.96 * Yu_z, col = "obs"
  )) +
  scale_color_manual(values = c("sim" = "blue", "obs" = "red")) +
  labs(colour = NULL, shape = "Events") +
  facet_wrap(~X1_obs, ncol = 2) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5), )

# Plot Q residuals
ggplot(residuals_event_mm_m3_s, aes(x = X3_obs)) +
  geom_point(aes(y = Y2_sim, col = "sim")) +
  labs(title = "MAP simulations vs boundary condition in Q", x = "Position (m)", y = "Q (L/s)") +
  geom_hline(aes(yintercept = 162, col = "boundary\nconditions", linetype = "1")) +
  scale_color_manual(values = c("sim" = "blue", "boundary\nconditions" = "red")) +
  scale_linetype_manual(values = c("1" = "dashed", "2" = "solid", "3" = "dotted", "4" = "twodash")) +
  labs(colour = NULL, shape = "Simulated\nevents", linetype = "boundary\ncondition\nevents") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5))
```


# Estimation with lower uncertainty for observations : 8 mm

## Check MCMC 
```{r}
path <- "/home/famendezrios/Documents/These/VSCODE-R/HydroBayes/HydroBayes_git/Case_studies/HHLab/Compound_channel_spatial_friction_test/Calibration/n_min_0_n_moy_4/"

mcmc <- read.table(
  file = file.path(path, "Results_MCMC.txt"),
  header = TRUE,
  stringsAsFactors = FALSE
)

# Trace plot for each parameter
mcmc <- readMCMC(file.path(path, "Results_MCMC.txt"))
plots <- tracePlot(mcmc)

wrap_plots(plots, ncol = 3)

# Density plot for each parameter
plots <- densityPlot(mcmc)
wrap_plots(plots, ncol = 3)
```

## Check summary

```{r}
getSummary <- read.table(
  file = file.path(path, "Results_Summary.txt"),
  header = TRUE,
  stringsAsFactors = FALSE
)

# Values of error model in meter for WSE, in m3/s for discharge and m/s for velocity.
knitr::kable(getSummary,
  align = "c"
)

# Zoom into the MAP and standard deviation of the error model
getSummary_zoom <- getSummary[c(11, 16), ]
indx_ZQ <- which(colnames(getSummary_zoom) %in% c("Y1_intercept", "Y2_intercept"))
indx_V <- which(colnames(getSummary_zoom) %in% c("Y3_intercept"))
getSummary_zoom[, indx_ZQ] <- getSummary_zoom[, indx_ZQ] * 1000 # Convert to mm for WSE and discharge
getSummary_zoom[, indx_V] <- getSummary_zoom[, indx_V] * 100 # Convert to cm/s for velocity
knitr::kable(getSummary_zoom,
  align = "c",
  caption = "Zoom into the MAP and standard deviation of the error model: WSE in mm, discharge in L/s and velocity in mm/s."
)
```

## Check spatial friction distribution

```{r}
n_degree <- 0
n_degree_flood <- 4
ks_literature <- data.frame(min = 1 / 0.013, max = 1 / 0.009, mean = 1 / 0.010)

# Get MAP simulation
MAP_param_matrix <- as.numeric(getSummary_zoom[2, c(1:(n_degree + 1 + n_degree_flood + 1))])

matrix_zFileKmin <- read.table(file.path(path, "Zfile_Kmin.txt"), header = TRUE)

position <- read.table(file.path(path, "vector_legendre.txt"), header = TRUE)

k_estimated_all <- as.data.frame(as.matrix(matrix_zFileKmin) %*% as.matrix(t(mcmc[, 1:(n_degree + 1)])))

k_estimated_all$KP <- position[, 2]

# Convert to long format
df_MCMC_sampling <- pivot_longer(
  k_estimated_all,
  cols = -KP,
  values_to = "Value"
) %>%
  select(KP, Value) %>%
  mutate(ID = "MCMC Sampling")

k_estimated_MAP <- as.matrix(matrix_zFileKmin) %*% MAP_param_matrix[1:(n_degree + 1)]

df_MAP <- data.frame(
  KP = position[, 2],
  Value = k_estimated_MAP,
  ID = "MAP"
)

# Get 95% uncertainty for envelope curve : create ribbon data from MCMC
df_envelope <- df_MCMC_sampling %>%
  filter(ID == "MCMC Sampling") %>%
  group_by(KP) %>%
  summarise(
    ymin = quantile(Value, probs = 0.025, na.rm = TRUE),
    ymax = quantile(Value, probs = 0.975, na.rm = TRUE),
    ID = "Parametric\nuncertainty", # so we can map to fill
    .groups = "drop"
  )

ggplot() +
  geom_ribbon(
    data = df_envelope,
    aes(x = KP, ymin = ymin, ymax = ymax, fill = ID)
  ) +
  geom_line(
    data = df_MAP,
    aes(x = KP, y = Value, color = ID)
  ) +
  geom_hline(aes(yintercept = ks_literature$min, linetype = "ASCI (1980)"), color = "gray") +
  geom_hline(aes(yintercept = ks_literature$max, linetype = "ASCI (1980)"), color = "gray") +
  geom_hline(aes(yintercept = ks_literature$mean, linetype = "ASCI (1980)"), color = "gray") +
  scale_fill_manual(values = c("Parametric\nuncertainty" = "pink")) +
  scale_color_manual(values = c("MAP" = "black")) +
  # Échelle de type de ligne
  scale_linetype_manual(
    name = "Reference\nvalues",
    values = c("ASCI (1980)" = "dashed")
  ) +
  labs(
    title = "Friction coefficient estimation in the main channel \nwith parametric uncertainty",
    x = "Lengthwise position (meters)",
    y = expression("Friction coefficient (m"^
      {
        1 / 3
      } * "/s)"),
    fill = "95% credibility\ninterval",
    color = NULL
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.title = element_text(hjust = 0.5)
  )
```

```{r}
# floodplain

matrix_zFileKflood <- read.table(file.path(path, "Zfile_Kflood.txt"), header = TRUE)

k_estimated_all_floodplain <- as.data.frame(as.matrix(matrix_zFileKflood) %*% as.matrix(t(mcmc[, (n_degree + 1 + 1):(n_degree + 1 + n_degree_flood + 1)])))

k_estimated_all_floodplain$KP <- position[, 2]

# Convert to long format
df_MCMC_sampling <- pivot_longer(
  k_estimated_all_floodplain,
  cols = -KP,
  values_to = "Value"
) %>%
  select(KP, Value) %>%
  mutate(ID = "MCMC Sampling")

k_estimated_MAP <- as.matrix(matrix_zFileKflood) %*% MAP_param_matrix[(n_degree + 1 + 1):(n_degree + 1 + n_degree_flood + 1)]

df_MAP <- data.frame(
  KP = position[, 2],
  Value = k_estimated_MAP,
  ID = "MAP"
)

# Get 95% uncertainty for envelope curve : create ribbon data from MCMC
df_envelope <- df_MCMC_sampling %>%
  filter(ID == "MCMC Sampling") %>%
  group_by(KP) %>%
  summarise(
    ymin = quantile(Value, probs = 0.025, na.rm = TRUE),
    ymax = quantile(Value, probs = 0.975, na.rm = TRUE),
    ID = "Parametric\nuncertainty", # so we can map to fill
    .groups = "drop"
  )

ggplot() +
  geom_ribbon(
    data = df_envelope,
    aes(x = KP, ymin = ymin, ymax = ymax, fill = ID)
  ) +
  geom_line(
    data = df_MAP,
    aes(x = KP, y = Value, color = ID)
  ) +
  geom_segment(aes(x = 0, xend = 9.05, y = ks_literature_floodplain_wood$min, yend = ks_literature_floodplain_wood$min, linetype = "Chow (1959)", color = "gray")) +
  geom_segment(aes(x = 0, xend = 9.05, y = ks_literature_floodplain_wood$max, yend = ks_literature_floodplain_wood$max, linetype = "Chow (1959)", color = "gray")) +
  geom_segment(aes(x = 0, xend = 9.05, y = ks_literature_floodplain_wood$mean, yend = ks_literature_floodplain_wood$mean, linetype = "Chow (1959)", color = "gray")) +
  geom_segment(aes(x = 9.05, xend = 18, y = ks_literature_floodplain_grass$min, yend = ks_literature_floodplain_grass$min, linetype = "Chow (1959)", color = "gray")) +
  geom_segment(aes(x = 9.05, xend = 18, y = ks_literature_floodplain_grass$max, yend = ks_literature_floodplain_grass$max, linetype = "Chow (1959)", color = "gray")) +
  geom_segment(aes(x = 9.05, xend = 18, y = ks_literature_floodplain_grass$mean, yend = ks_literature_floodplain_grass$mean, linetype = "Chow (1959)", color = "gray")) +
  scale_fill_manual(values = c("Parametric\nuncertainty" = "pink")) +
  scale_color_manual(values = c("MAP" = "black")) +
  # Échelle de type de ligne
  scale_linetype_manual(
    name = "Reference\nvalues",
    values = c("Chow (1959)" = "dashed")
  ) +
  labs(
    title = "Friction coefficient estimation in the floodplain \nwith parametric uncertainty",
    x = "Lengthwise position (meters)",
    y = expression("Friction coefficient (m"^
      {
        1 / 3
      } * "/s)"),
    fill = "95% credibility\ninterval",
    color = NULL
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.title = element_text(hjust = 0.5)
  )
```

### Partial conclusions:

Results are not very satisfatory, but they are more coherent than results from a polynomial degree of 2. More degrees of freedom is assigned to the polynomial, estimation will be more precise, but model will be more complex and instabilities could appear.

## Check of residuals

```{r}
# Read residuals
residuals <- read.table(
  file = file.path(path, "Results_Residuals.txt"),
  header = TRUE,
  stringsAsFactors = FALSE
)

# Replace -9999 and -1e9 with NA
residuals[residuals == -9999] <- NA
residuals[residuals == -1e9] <- NA

# Convert residuals to mm and m3/s
residuals_mm_m3_s <- data.frame(
  residuals[, 1:4],
  residuals[, c(9, 19, 20, 24, 29)] * 1000
)


getCalData <- read.table(
  file = file.path(path, "CalibrationData.txt"),
  header = TRUE,
  stringsAsFactors = FALSE
)
knitr::kable(getCalData,
  align = "c"
)
getCalData[, c("WSE", "Yu_z")] <- getCalData[, c("WSE", "Yu_z")] * 1000

residuals_event_mm_m3_s <- data.frame(residuals_mm_m3_s, Yu_z = getCalData[, "Yu_z"])

# Plot WSE residuals
ggplot(residuals_event_mm_m3_s, aes(x = X3_obs)) +
  geom_point(aes(y = Y1_sim, col = "sim")) +
  labs(title = "MAP simulations vs Observations (WSE)", x = "Position (m)", y = "Water surface elevation (mm)") +
  geom_point(aes(y = Y1_obs, col = "obs")) +
  geom_errorbar(aes(
    ymin = Y1_obs - 1.96 * Yu_z,
    ymax = Y1_obs + 1.96 * Yu_z, col = "obs"
  )) +
  scale_color_manual(values = c("sim" = "blue", "obs" = "red")) +
  labs(colour = NULL, shape = "Events") +
  facet_wrap(~X1_obs, ncol = 2) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5), )

# Plot Q residuals
ggplot(residuals_event_mm_m3_s, aes(x = X3_obs)) +
  geom_point(aes(y = Y2_sim, col = "sim")) +
  labs(title = "MAP simulations vs boundary condition in Q", x = "Position (m)", y = "Q (L/s)") +
  geom_hline(aes(yintercept = 162, col = "boundary\nconditions", linetype = "1")) +
  scale_color_manual(values = c("sim" = "blue", "boundary\nconditions" = "red")) +
  scale_linetype_manual(values = c("1" = "dashed", "2" = "solid", "3" = "dotted", "4" = "twodash")) +
  labs(colour = NULL, shape = "Simulated\nevents", linetype = "boundary\ncondition\nevents") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5))
```

## Main conclusions:

- Thee streamwise distance as covariant to spatial distribute the friction coefficient is not enough to estimate the friction coefficient when the roughness changes suddenly. Changes are modelized smoothly, but the real-world conditions are not. 

# Bibliography: