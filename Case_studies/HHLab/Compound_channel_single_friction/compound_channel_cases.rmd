---
title: "Compound channel hydraulic flume (n_min = 0 n_flood = 1)"
author: "Felipe"
date: "`r Sys.Date()`"
output: html_document
---


```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = FALSE
)
```
# Experimental set up

A compound channel setup was used for this case study with the follow specifications:

  - Length: 18 m
  - Width: 3 m
  - Slope: 0.0011
  - Main channel: 1 m wide rectangular glass bed
  - Floodplain: two 1 m wide flat rough-surface covered with dense artificial grass (consisting of 1 mm wide and 5 mm high thin rigid blades, with a density of 256 blades per square centimeter).
  - Vertical distance from the main channel to the floodplain: 0.117 m
  - Flow conditions: uniform flow with a total discharge of 114 L/s, of which 8 L/s passed through the floodplain
  -  Water level measurements: taken at spatial intervals of 0.3 to 1 m along the streamwise direction, at transverse positions at y=0.3 and 0.7 m on the right-hand floodplain and at y=1.2, 1.5 and 1.8 m in the main channel.

```{r}
knitr::include_graphics("/home/famendezrios/Documents/These/VSCODE-R/HydroBayes/HydroBayes_git/Case_studies/HHLab/Compound_channel_single_friction/compound_channel.png")
```

```{r load-packages, message = FALSE, include= FALSE}
library(RBaM)
library(patchwork)
library(ggplot2)
library(dplyr)
library(tidyr)
```

# Objectives and remarks of the case study

- Test case to evaluate the estimation independently of the friction in the main channel and the floodplain. 
- The case features a constant longitudinal friction, but with different values for the main channel and the floodplain.
- No measurements of the downstream threshold were reported. Therefore, the last available measurements were taken to define the downstream boundary condition in the model.
- Mage is a 1D hydraulic model that provides average simulations of discharge, velocity and water surface elevation for each cross-section.
- Depth measurements were taken in both the main channel and the floodplain. For this case, an average value was calculated for each cross-section to compare with the simulations. All averaged depth values were converted to elevation using the downstream as the reference datum. 

# Calibration data

A sample was taken of all measurements for this case.
```{r}
path <- "/home/famendezrios/Documents/These/VSCODE-R/HydroBayes/HydroBayes_git/Case_studies/HHLab/Compound_channel_single_friction/Calibration/n_0"

load("/home/famendezrios/Documents/These/VSCODE-R/HydroBayes/HydroBayes_git/data/processed_data/HHLab/compound_single_friction/data_HHLab_uniform_case.RData")

WSE_data_temp <- all_data_calibration$WSE

WSE_data <- data.frame(WSE_data_temp %>%
  group_by(x) %>%
  summarise(
    z_mean_all = mean(z_mean),
    Yu_mean_all = mean(Yu),
    z_riverbed = mean(z_riverbed)
  ))

Cal_measures <- c(3.5, 5, 6.5, 7, 7.5, 9.25, 11.75, 12.5, 13)

CalData_sample <- WSE_data[WSE_data$x %in% Cal_measures, ]
CalData_sample[, -1] <- CalData_sample[, -1] * 1000
# Read calibration data and summary
getCalData <- read.table(
  file = file.path(path, "CalibrationData.txt"),
  header = TRUE,
  stringsAsFactors = FALSE
)
knitr::kable(getCalData,
  align = "c"
)
getCalData[, c("WSE", "Yu_z")] <- getCalData[, c("WSE", "Yu_z")] * 1000

ggplot() +
  geom_point(data = getCalData, aes(
    x = x, y = WSE, col = "obs"
  )) +
  geom_errorbar(data = getCalData, aes(
    x = x, y = WSE,
    ymin = WSE - Yu_z, ymax = WSE + Yu_z, col = "obs"
  )) +
  geom_line(
    data = CalData_sample,
    aes(x = x, y = z_riverbed, col = "river bed")
  ) +
  labs(
    title = "WSE observations",
    x = "Lengthwise position (meters)",
    y = "Water level elevation (mm)",
    color = NULL
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.title = element_text(hjust = 0.5)
  )
```

# Estimation: constant in the main channel and the floodplain

## Check MCMC
```{r}
mcmc <- read.table(
  file = file.path(path, "Results_MCMC.txt"),
  header = TRUE,
  stringsAsFactors = FALSE
)

# Trace plot for each parameter
mcmc <- readMCMC(file.path(path, "Results_MCMC.txt"))
plots <- tracePlot(mcmc)

wrap_plots(plots, ncol = 3)

# Density plot for each parameter
plots <- densityPlot(mcmc)
wrap_plots(plots, ncol = 3)
```

### Partial conclusions:

Results shows that a0 for the main channel was not totally converge yet. For the floodplain, a better convergence is found, but it could be better. Maybe non informative information leds to get a high acceptance rate of combinations.

## Check summary

```{r}
getSummary <- read.table(
  file = file.path(path, "Results_Summary.txt"),
  header = TRUE,
  stringsAsFactors = FALSE
)

# Values of error model in meter for WSE, in m3/s for discharge and m/s for velocity.
knitr::kable(getSummary,
  align = "c"
)

# Zoom into the MAP and standard deviation of the error model
getSummary_zoom <- getSummary[c(11, 16), ]
getSummary_zoom[, -c(1, 2, 5, 6, 7)] <- getSummary_zoom[, -c(1, 2, 5, 6, 7)] * 1000 # Convert to mm for WSE and discharge
getSummary_zoom[, 5] <- getSummary_zoom[, 5] * 100 # Convert to cm/s for velocity
knitr::kable(getSummary_zoom,
  align = "c",
  caption = "Zoom into the MAP and standard deviation of the error model: WSE in mm, discharge in L/s and velocity in mm/s."
)
```

## Check spatial friction distribution

```{r}
n_degree <- 0

ks_literature <- data.frame(min = 1 / 0.013, max = 1 / 0.009, mean = 1 / 0.010)

# Get MAP simulation
MAP_param_matrix <- as.numeric(getSummary_zoom[2, c(1:(n_degree + 1 + 1))])

matrix_zFileKmin <- read.table(file.path(path, "Zfile_Kmin.txt"), header = TRUE)

position <- read.table(file.path(path, "vector_legendre.txt"), header = TRUE)

k_estimated_all <- as.data.frame(as.matrix(matrix_zFileKmin) %*% as.matrix(t(mcmc[, 1:(n_degree + 1)])))

k_estimated_all$KP <- position[, 2]

# Convert to long format
df_MCMC_sampling <- pivot_longer(
  k_estimated_all,
  cols = -KP,
  values_to = "Value"
) %>%
  select(KP, Value) %>%
  mutate(ID = "MCMC Sampling")

k_estimated_MAP <- as.matrix(matrix_zFileKmin) %*% MAP_param_matrix[1]

df_MAP <- data.frame(
  KP = position[, 2],
  Value = k_estimated_MAP,
  ID = "MAP"
)

# Get 95% uncertainty for envelope curve : create ribbon data from MCMC
df_envelope <- df_MCMC_sampling %>%
  filter(ID == "MCMC Sampling") %>%
  group_by(KP) %>%
  summarise(
    ymin = quantile(Value, probs = 0.025, na.rm = TRUE),
    ymax = quantile(Value, probs = 0.975, na.rm = TRUE),
    ID = "Parametric\nuncertainty", # so we can map to fill
    .groups = "drop"
  )

ggplot() +
  geom_ribbon(
    data = df_envelope,
    aes(x = KP, ymin = ymin, ymax = ymax, fill = ID)
  ) +
  geom_line(
    data = df_MAP,
    aes(x = KP, y = Value, color = ID)
  ) +
  geom_hline(aes(yintercept = ks_literature$min, linetype = "ASCI (1980)"), color = "gray") +
  geom_hline(aes(yintercept = ks_literature$max, linetype = "ASCI (1980)"), color = "gray") +
  geom_hline(aes(yintercept = ks_literature$mean, linetype = "ASCI (1980)"), color = "gray") +
  scale_fill_manual(values = c("Parametric\nuncertainty" = "pink")) +
  scale_color_manual(values = c("MAP" = "black")) +
  # Échelle de type de ligne
  scale_linetype_manual(
    name = "Reference\nvalues",
    values = c("ASCI (1980)" = "dashed")
  ) +
  labs(
    title = "Friction coefficient estimation in the main channel \nwith parametric uncertainty",
    x = "Lengthwise position (meters)",
    y = expression("Friction coefficient (m"^
      {
        1 / 3
      } * "/s)"),
    fill = "95% credibility\ninterval",
    color = NULL
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.title = element_text(hjust = 0.5)
  )
```

```{r}
# floodplain
n_degree_flood <- 0

ks_literature_floodplain <- data.frame(min = 1 / 0.05, max = 1 / 0.025, mean = 1 / 0.033)

matrix_zFileKflood <- read.table(file.path(path, "Zfile_Kflood.txt"), header = TRUE)

k_estimated_all_floodplain <- as.data.frame(as.matrix(matrix_zFileKflood) %*% as.matrix(t(mcmc[, (n_degree + 1 + 1):(n_degree + 1 + n_degree_flood + 1)])))

k_estimated_all_floodplain$KP <- position[, 2]

# Convert to long format
df_MCMC_sampling <- pivot_longer(
  k_estimated_all_floodplain,
  cols = -KP,
  values_to = "Value"
) %>%
  select(KP, Value) %>%
  mutate(ID = "MCMC Sampling")

k_estimated_MAP <- as.matrix(matrix_zFileKflood) %*% MAP_param_matrix[2]

df_MAP <- data.frame(
  KP = position[, 2],
  Value = k_estimated_MAP,
  ID = "MAP"
)

# Get 95% uncertainty for envelope curve : create ribbon data from MCMC
df_envelope <- df_MCMC_sampling %>%
  filter(ID == "MCMC Sampling") %>%
  group_by(KP) %>%
  summarise(
    ymin = quantile(Value, probs = 0.025, na.rm = TRUE),
    ymax = quantile(Value, probs = 0.975, na.rm = TRUE),
    ID = "Parametric\nuncertainty", # so we can map to fill
    .groups = "drop"
  )

ggplot() +
  geom_ribbon(
    data = df_envelope,
    aes(x = KP, ymin = ymin, ymax = ymax, fill = ID)
  ) +
  geom_line(
    data = df_MAP,
    aes(x = KP, y = Value, color = ID)
  ) +
  geom_hline(aes(yintercept = ks_literature_floodplain$min, linetype = "Chow (1959)"), color = "gray") +
  geom_hline(aes(yintercept = ks_literature_floodplain$max, linetype = "Chow (1959)"), color = "gray") +
  geom_hline(aes(yintercept = ks_literature_floodplain$mean, linetype = "Chow (1959)"), color = "gray") +
  scale_fill_manual(values = c("Parametric\nuncertainty" = "pink")) +
  scale_color_manual(values = c("MAP" = "black")) +
  # Échelle de type de ligne
  scale_linetype_manual(
    name = "Reference\nvalues",
    values = c("Chow (1959)" = "dashed")
  ) +
  labs(
    title = "Friction coefficient estimation in the floodplain \nwith parametric uncertainty",
    x = "Lengthwise position (meters)",
    y = expression("Friction coefficient (m"^
      {
        1 / 3
      } * "/s)"),
    fill = "95% credibility\ninterval",
    color = NULL
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.title = element_text(hjust = 0.5)
  )
```

### Partial conclusions:

- Friction in the main channel is in the range of reference values from the literature. 
- A higher Strickler coefficient in the floodplain was found. Probably, to compensate the residuals.  

## Check of residuals

```{r}
# Read residuals
residuals <- read.table(
  file = file.path(path, "Results_Residuals.txt"),
  header = TRUE,
  stringsAsFactors = FALSE
)

# Replace -9999 and -1e9 with NA
residuals[residuals == -9999] <- NA
residuals[residuals == -1e9] <- NA

# Convert residuals to mm and m3/s
residuals_mm_m3_s <- data.frame(
  residuals[, 1:8],
  residuals[, -c(1:8, 21, 22, 23, 26, 27, 28, 31, 32, 33)] * 1000
)

residuals_event_mm_m3_s <- data.frame(getCalData[, 1:4], residuals_mm_m3_s, Yu_z = getCalData[, "Yu_z"])

# Plot WSE residuals
ggplot(residuals_event_mm_m3_s, aes(x = X3_obs)) +
  geom_point(aes(y = Y1_sim, col = "sim")) +
  labs(title = "MAP simulations vs Observations (WSE)", x = "Position (m)", y = "Water surface elevation (mm)") +
  geom_point(aes(y = Y1_obs, col = "obs")) +
  geom_errorbar(aes(
    ymin = Y1_obs - 1.96 * Yu_z,
    ymax = Y1_obs + 1.96 * Yu_z, col = "obs"
  )) +
  scale_color_manual(values = c("sim" = "blue", "obs" = "red")) +
  labs(colour = NULL, shape = "Events") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5), )

# Plot Q residuals
ggplot(residuals_event_mm_m3_s, aes(x = X3_obs)) +
  geom_point(aes(y = Y2_sim, col = "sim")) +
  labs(title = "MAP simulations vs boundary condition in Q", x = "Position (m)", y = "Q (L/s)") +
  geom_hline(aes(yintercept = 114, col = "boundary\nconditions", linetype = "1")) +
  scale_color_manual(values = c("sim" = "blue", "boundary\nconditions" = "red")) +
  scale_linetype_manual(values = c("1" = "dashed", "2" = "solid", "3" = "dotted", "4" = "twodash")) +
  labs(colour = NULL, shape = "Simulated\nevents", linetype = "boundary\ncondition\nevents") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5))
```

### Partial conclusions:

All simulations of MAP estimation are passing through the observed data with their uncertainty.

# Estimation (n_kmin = 0 and n_kflood = 1)

This calibration cas considers a constant friction in the main channel and a linear spatialisation of the friction in the floodplain. Non informative prior were given to the parameters (FlatPrior).

## Check MCMC 
```{r}
path <- "/home/famendezrios/Documents/These/VSCODE-R/HydroBayes/HydroBayes_git/Case_studies/HHLab/Compound_channel_single_friction/Calibration"

mcmc <- read.table(
  file = file.path(path, "Results_MCMC.txt"),
  header = TRUE,
  stringsAsFactors = FALSE
)

# Trace plot for each parameter
mcmc <- readMCMC(file.path(path, "Results_MCMC.txt"))
plots <- tracePlot(mcmc)

wrap_plots(plots, ncol = 3)

# Density plot for each parameter
plots <- densityPlot(mcmc)
wrap_plots(plots, ncol = 3)
```

### Partial conclusions:

With around 5000 simulations, no convergence for the a0_min and a0_flood was found. It seems that a large number of combinations of parameters are accepted during the exploration. It leads to think that a better prior at least for a0 should be done, even if it is large. 

The parameter a1 for the floodplain is varying mostly between -5 to 5, with a lower dispersion or spread.   

## Check summary

```{r}
getSummary <- read.table(
  file = file.path(path, "Results_Summary.txt"),
  header = TRUE,
  stringsAsFactors = FALSE
)

# Values of error model in meter for WSE, in m3/s for discharge and m/s for velocity.
knitr::kable(getSummary,
  align = "c"
)

# Zoom into the MAP and standard deviation of the error model
getSummary_zoom <- getSummary[c(11, 16), ]
getSummary_zoom[, 4:5] <- getSummary_zoom[, 4:5] * 1000 # Convert to mm for WSE and discharge
getSummary_zoom[, 6] <- getSummary_zoom[, 6] * 100 # Convert to cm/s for velocity
knitr::kable(getSummary_zoom,
  align = "c",
  caption = "Zoom into the MAP and standard deviation of the error model: WSE in mm, discharge in L/s and velocity in mm/s."
)
```

## Check spatial friction distribution

```{r}
n_degree <- 0
n_degree_flood <- 1
ks_literature <- data.frame(min = 1 / 0.013, max = 1 / 0.009, mean = 1 / 0.010)

# Get MAP simulation
MAP_param_matrix <- as.numeric(getSummary_zoom[2, c(1:(n_degree + 1 + n_degree_flood + 1))])

matrix_zFileKmin <- read.table(file.path(path, "Zfile_Kmin.txt"), header = TRUE)

position <- read.table(file.path(path, "vector_legendre.txt"), header = TRUE)

k_estimated_all <- as.data.frame(as.matrix(matrix_zFileKmin) %*% as.matrix(t(mcmc[, 1:(n_degree + 1)])))

k_estimated_all$KP <- position[, 2]

# Convert to long format
df_MCMC_sampling <- pivot_longer(
  k_estimated_all,
  cols = -KP,
  values_to = "Value"
) %>%
  select(KP, Value) %>%
  mutate(ID = "MCMC Sampling")

k_estimated_MAP <- as.matrix(matrix_zFileKmin) %*% MAP_param_matrix[1]

df_MAP <- data.frame(
  KP = position[, 2],
  Value = k_estimated_MAP,
  ID = "MAP"
)

# Get 95% uncertainty for envelope curve : create ribbon data from MCMC
df_envelope <- df_MCMC_sampling %>%
  filter(ID == "MCMC Sampling") %>%
  group_by(KP) %>%
  summarise(
    ymin = quantile(Value, probs = 0.025, na.rm = TRUE),
    ymax = quantile(Value, probs = 0.975, na.rm = TRUE),
    ID = "Parametric\nuncertainty", # so we can map to fill
    .groups = "drop"
  )

ggplot() +
  geom_ribbon(
    data = df_envelope,
    aes(x = KP, ymin = ymin, ymax = ymax, fill = ID)
  ) +
  geom_line(
    data = df_MAP,
    aes(x = KP, y = Value, color = ID)
  ) +
  geom_hline(aes(yintercept = ks_literature$min, linetype = "ASCI (1980)"), color = "gray") +
  geom_hline(aes(yintercept = ks_literature$max, linetype = "ASCI (1980)"), color = "gray") +
  geom_hline(aes(yintercept = ks_literature$mean, linetype = "ASCI (1980)"), color = "gray") +
  scale_fill_manual(values = c("Parametric\nuncertainty" = "pink")) +
  scale_color_manual(values = c("MAP" = "black")) +
  # Échelle de type de ligne
  scale_linetype_manual(
    name = "Reference\nvalues",
    values = c("ASCI (1980)" = "dashed")
  ) +
  labs(
    title = "Friction coefficient estimation in the main channel \nwith parametric uncertainty",
    x = "Lengthwise position (meters)",
    y = expression("Friction coefficient (m"^
      {
        1 / 3
      } * "/s)"),
    fill = "95% credibility\ninterval",
    color = NULL
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.title = element_text(hjust = 0.5)
  )
```

```{r}
# floodplain
ks_literature_floodplain <- data.frame(min = 1 / 0.05, max = 1 / 0.025, mean = 1 / 0.033)

matrix_zFileKflood <- read.table(file.path(path, "Zfile_Kflood.txt"), header = TRUE)

k_estimated_all_floodplain <- as.data.frame(as.matrix(matrix_zFileKflood) %*% as.matrix(t(mcmc[, (n_degree + 1 + 1):(n_degree + 1 + n_degree_flood + 1)])))

k_estimated_all_floodplain$KP <- position[, 2]

# Convert to long format
df_MCMC_sampling <- pivot_longer(
  k_estimated_all_floodplain,
  cols = -KP,
  values_to = "Value"
) %>%
  select(KP, Value) %>%
  mutate(ID = "MCMC Sampling")

k_estimated_MAP <- as.matrix(matrix_zFileKflood) %*% MAP_param_matrix[c(2, 3)]

df_MAP <- data.frame(
  KP = position[, 2],
  Value = k_estimated_MAP,
  ID = "MAP"
)

# Get 95% uncertainty for envelope curve : create ribbon data from MCMC
df_envelope <- df_MCMC_sampling %>%
  filter(ID == "MCMC Sampling") %>%
  group_by(KP) %>%
  summarise(
    ymin = quantile(Value, probs = 0.025, na.rm = TRUE),
    ymax = quantile(Value, probs = 0.975, na.rm = TRUE),
    ID = "Parametric\nuncertainty", # so we can map to fill
    .groups = "drop"
  )

ggplot() +
  geom_ribbon(
    data = df_envelope,
    aes(x = KP, ymin = ymin, ymax = ymax, fill = ID)
  ) +
  geom_line(
    data = df_MAP,
    aes(x = KP, y = Value, color = ID)
  ) +
  geom_hline(aes(yintercept = ks_literature_floodplain$min, linetype = "Chow (1959)"), color = "gray") +
  geom_hline(aes(yintercept = ks_literature_floodplain$max, linetype = "Chow (1959)"), color = "gray") +
  geom_hline(aes(yintercept = ks_literature_floodplain$mean, linetype = "Chow (1959)"), color = "gray") +
  scale_fill_manual(values = c("Parametric\nuncertainty" = "pink")) +
  scale_color_manual(values = c("MAP" = "black")) +
  # Échelle de type de ligne
  scale_linetype_manual(
    name = "Reference\nvalues",
    values = c("Chow (1959)" = "dashed")
  ) +
  labs(
    title = "Friction coefficient estimation in the floodplain \nwith parametric uncertainty",
    x = "Lengthwise position (meters)",
    y = expression("Friction coefficient (m"^
      {
        1 / 3
      } * "/s)"),
    fill = "95% credibility\ninterval",
    color = NULL
  ) +
  theme_bw() +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.title = element_text(hjust = 0.5)
  )
```

### Partial conclusions:

- In the main channel, the MAP is around 120 for Strickler coefficient. This estimated value are not realistic with the Strickler reference values varying from around 80 - 112.
- In the floodplain, the MAP estimation is in according to reference values. However, the uncertainty is so large even if any burn and slim step was performed. 

## Check of residuals

```{r}
# Read residuals
residuals <- read.table(
  file = file.path(path, "Results_Residuals.txt"),
  header = TRUE,
  stringsAsFactors = FALSE
)

# Replace -9999 and -1e9 with NA
residuals[residuals == -9999] <- NA
residuals[residuals == -1e9] <- NA

# Convert residuals to mm and m3/s
residuals_mm_m3_s <- data.frame(
  residuals[, 1:8],
  residuals[, -c(1:8, 21, 22, 23, 26, 27, 28, 31, 32, 33)] * 1000
)

residuals_event_mm_m3_s <- data.frame(getCalData[, 1:4], residuals_mm_m3_s, Yu_z = getCalData[, "Yu_z"])

# Plot WSE residuals
ggplot(residuals_event_mm_m3_s, aes(x = X3_obs)) +
  geom_point(aes(y = Y1_sim, col = "sim")) +
  labs(title = "MAP simulations vs Observations (WSE)", x = "Position (m)", y = "Water surface elevation (mm)") +
  geom_point(aes(y = Y1_obs, col = "obs")) +
  geom_errorbar(aes(
    ymin = Y1_obs - 1.96 * Yu_z,
    ymax = Y1_obs + 1.96 * Yu_z, col = "obs"
  )) +
  scale_color_manual(values = c("sim" = "blue", "obs" = "red")) +
  labs(colour = NULL, shape = "Events") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5), )

# Plot Q residuals
ggplot(residuals_event_mm_m3_s, aes(x = X3_obs)) +
  geom_point(aes(y = Y2_sim, col = "sim")) +
  labs(title = "MAP simulations vs boundary condition in Q", x = "Position (m)", y = "Q (L/s)") +
  geom_hline(aes(yintercept = 114, col = "boundary\nconditions", linetype = "1")) +
  scale_color_manual(values = c("sim" = "blue", "boundary\nconditions" = "red")) +
  scale_linetype_manual(values = c("1" = "dashed", "2" = "solid", "3" = "dotted", "4" = "twodash")) +
  labs(colour = NULL, shape = "Simulated\nevents", linetype = "boundary\ncondition\nevents") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5))
```

### Partial conclusions:

All simulations are very close to the observed stages. Even though the flow condition is uniform, the observations are not as linear as the simulations because of real-world conditions and the averaging process applied before comparing the simulations and observations.

## Main conclusions:

- A more informative prior is necessary, at least for a0 of the main channel and the floodplain, in order to discard unrealistic combinations. 
- In a constant spatial distributed friction, the coefficient found in the main channel is in accord with reference values, but the friction value in floodplain is not realistic.
- In the linear spatial distributed friction for floodplain, a better estimation of the friction in floodplain was found, but a not realistic value is estimated in the main channel.

# Remarks:

the measurements used for this case are averages of values taken separately in the floodplain and the main channel. In addition, the upstream discharge was divided in the experiment, which may have influenced the first measurements. The model's simulations are average values by cross-sections, considering a total discharge constant without difference between main channel or floodplain.  
