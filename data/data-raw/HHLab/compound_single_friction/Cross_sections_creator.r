rm(list = ls())

points <- c(
    0,
    18
)

Cross_sections_boundary <-
    list(
        list(
            kp = 18,
            xyz = data.frame(
                x = rep(18, 8),
                y = c(3, 3, 2, 2, 1, 1, 0, 0),
                z = c(0.3, 0.117, 0.117, 0, 0, 0.117, 0.117, 0.3)
            )
        ),
        So = 1.1e-3
    )

positions_interface <- c(3, 6)

# Function to perform linear interpolation
interpolate_kp <- function(kp_query, positions_interface) {
    # Initialize a matrix to store the interpolated results
    xyz_interpolated <- matrix(nrow = 0, ncol = 4)


    # Loop through each row of the xyz data
    for (i in 1:nrow(Cross_sections_boundary[[1]]$xyz)) {
        x0 <- Cross_sections_boundary[[1]]$xyz$x[i]
        y0 <- Cross_sections_boundary[[1]]$xyz$y[i]
        z0 <- Cross_sections_boundary[[1]]$xyz$z[i]

        slope <- Cross_sections_boundary$So

        # Calculate the interpolated values
        x <- kp_query
        y <- y0
        z <- z0 + (x0 - x) * slope

        # Add the interpolated results to the matrix
        if (i == 1) {
            xyz_interpolated <- rbind(xyz_interpolated, c(x, y, z, ""))
        } else if (i == positions_interface[1]) {
            xyz_interpolated <- rbind(xyz_interpolated, c(x, y, z, "rg"))
        } else if (i == positions_interface[2]) {
            xyz_interpolated <- rbind(xyz_interpolated, c(x, y, z, "rd"))
        } else {
            xyz_interpolated <- rbind(xyz_interpolated, c(x, y, z, ""))
        }
    }
    return(xyz_interpolated)
}
points_cross_sections <- c(
    0, 1, 2, 2.5, 3, 3.5, 4, 4.5, 5, 6,
    7, 7.5, 8, 9, 9.5, 10, 11, 11.5, 12,
    13, 14, 14.5, 15, 16, 16.5, 17, 18
)
results <- lapply(points_cross_sections, interpolate_kp, positions_interface = positions_interface)

# Créer un data frame vide pour stocker les résultats
formatted_data <- data.frame(
    V1 = integer(),
    V2 = integer(),
    V3 = integer(),
    V4 = numeric(),
    V5 = numeric(),
    V6 = character()
)

# Remplir le data frame avec les données formatées
for (i in seq_along(points_cross_sections)) {
    new_row <- data.frame(
        V1 = 1,
        V2 = 0,
        V3 = 0,
        V4 = 8,
        V5 = points_cross_sections[i],
        V6 = sprintf("p%03d", i)
    )
    formatted_data <- rbind(formatted_data, new_row)
}


# File path for output
file_path <- "/home/famendezrios/Documents/These/VSCODE-R/HydroBayes/HydroBayes_git/data/processed_data/HHLab/compound_single_friction/Reach_002.ST"

# Open the file for writing
file_conn <- file(file_path, open = "wt")

# Write the header
writeLines("# This file is generated by PAMHYR, please don't modify", file_conn)

# Write formatted data
for (i in 1:nrow(formatted_data)) {
    # Write formatted_data line
    writeLines(
        sprintf(
            "%6d%6d%6d%6d%12.6f %s",
            formatted_data[i, "V1"],
            formatted_data[i, "V2"],
            formatted_data[i, "V3"],
            formatted_data[i, "V4"],
            formatted_data[i, "V5"],
            formatted_data[i, "V6"]
        ),
        file_conn
    )

    # Write results matrix
    if (i <= length(results) && nrow(results[[i]]) > 0) {
        for (j in 1:nrow(results[[i]])) {
            # Initialize a character vector to build the line
            line_parts <- character(0)

            # Format each element according to its type
            for (k in 1:min(4, ncol(results[[i]]))) {
                if (is.numeric(results[[i]][j, k])) {
                    line_parts <- c(line_parts, sprintf("%12.4f", results[[i]][j, k]))
                } else {
                    line_parts <- c(line_parts, sprintf("%12s", results[[i]][j, k]))
                }
            }

            # Combine the parts into a single line
            line <- paste(line_parts, collapse = "")
            writeLines(line, file_conn)
        }
    }

    # Add a separator line
    writeLines(sprintf("%12.3f%12.3f%12.3f", 999.999, 999.999, 999.999), file_conn)
}

# Close the file
close(file_conn)
