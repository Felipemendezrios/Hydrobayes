rm(list = ls())
graphics.off()

# Interpolation function passing by some specific nodes:
interpolation_specific_points <- function(total_points = 100,
                                          specific_nodes) {
    if (total_points <= length(specific_nodes)) stop("Total points defined is lower or equal to the specific points required. Please either increase the number of total_points or avoid to used interpolation function")

    # Order specific_nodes
    specific_nodes <- sort(specific_nodes)

    # Calculate the intervals between the specific points
    intervals <- diff(specific_nodes)
    # Distribute the number of points proportionally to each interval
    total_local_points <- total_points - 1 # last value during diff function
    points_per_interval_float <- (intervals / sum(intervals)) * total_local_points

    points_per_interval <- round(points_per_interval_float)

    # Generate sub-sequences for each interval, excluding the duplicate endpoint
    specific_seq_temp <- unlist(mapply(
        function(start, end, n) seq(start, end, length.out = n + 1)[-(n + 1)], # Exclude the endpoint
        specific_nodes[-length(specific_nodes)], # Start of each interval
        specific_nodes[-1], # End of each interval
        points_per_interval # Number of points per interval
    ))

    # Add the final endpoint manually
    specific_seq <-
        c(
            specific_seq_temp,
            last(specific_nodes)
        )


    if (!all(specific_nodes %in% specific_seq)) stop("Distance so close, increase number of interpolate KP to get all points required")

    return(specific_seq)
}

last <- function(data) {
    tail(data, n = 1)
}

getlegendre <- function(
    polynomial_degree,
    covariate_discretization) {
    if (length(unique(covariate_discretization)) == 1) {
        stop("covariate_discretization must contain more than one unique value")
    }
    normalized_values <- 2 * (covariate_discretization - min(covariate_discretization)) / (max(covariate_discretization) - min(covariate_discretization)) - 1

    # Write co variant matrix for main channel
    # Create an empty data frame and fill it with polynomial values
    legendre_df_covariate <- data.frame(x = normalized_values) # Start with x values
    legendre_df <- legendre_df_covariate

    if (polynomial_degree < 0) stop("The polynomial degree must be positive")
    if (any(!dplyr::between(normalized_values, -1, 1))) stop("Range of normalized_values should be between [-1,1]")

    if (polynomial_degree == 0) {
        return(rep(1, length(normalized_values)))
    }
    if (polynomial_degree == 1) {
        return(normalized_values)
    }

    # P_0(normalized_values) = 1
    Pn_1 <- rep(1, length(normalized_values))
    # P_1(normalized_values) = normalized_values
    Pn <- normalized_values

    for (k in 1:(polynomial_degree - 1)) {
        P_next <- ((2 * k + 1) * normalized_values * Pn - k * Pn_1) / (k + 1)
        Pn_1 <- Pn
        Pn <- P_next
    }
    return(Pn)
}

# Function to get covariate in Legendre polynomial
getCovariate_Legendre <- function(max_polynomial_degree, ...) {
    if (!(max_polynomial_degree >= 0 && max_polynomial_degree == floor(max_polynomial_degree))) stop("max_polynomial_degree must be a positive integer")

    # Capture the first argument passed via ...
    args <- list(...)
    # Check if required arguments are present
    if (!("covariate_discretization" %in% names(args))) {
        stop("covariate_discretization must be provided as a named argument")
    }
    # Extract covariate_discretization
    covariate_discretization <- args$covariate_discretization

    Z <- matrix(
        data = 0,
        nrow = length(covariate_discretization),
        ncol = max_polynomial_degree + 1 # Because degrees start at 0
    )
    for (polynomial_degree in seq(0, max_polynomial_degree)) {
        Z[, polynomial_degree + 1] <- getlegendre(
            polynomial_degree = polynomial_degree,
            covariate_discretization = covariate_discretization
        )
    }

    return(Z)
}



write_RUGFile <- function(RUG_path,
                          RUGFile_data,
                          RUG_format) {
    # Open a .RUG file for writing
    fileConn <- file(RUG_path, "w")
    # Write the first line as a comment
    writeLines("* This file is generated by PAMHYR, please don't modify", fileConn)
    formatted_lines <- sapply(1:nrow(RUGFile_data), function(i) {
        sprintf(
            RUG_format,
            "K",
            RUGFile_data$id_reach[i],
            RUGFile_data$KP_start[i],
            RUGFile_data$KP_end[i],
            RUGFile_data$Kmin[i],
            RUGFile_data$Kflood[i]
        )
    })

    # Write the formatted lines to the file
    writeLines(formatted_lines, fileConn)


    # Close the file
    close(fileConn)
}

# Function to assign reach to a grid
assign_reach_from_a_grid <- function(reach_KP_boundaries, grid, Logical_decreasing) {
    grid_with_reaches <- data.frame(
        reaches = rep(NA, length(grid)),
        grid = rep(NA, length(grid))
    )

    if (nrow(reach_KP_boundaries) == 1) {
        all_set <- dplyr::between(grid, reach_KP_boundaries$KP_start, reach_KP_boundaries$KP_end)
        if (!all(all_set)) stop("reach_KP_boundaries must contain all grid")
        grid_with_reaches$reaches[which(all_set)] <- reach_KP_boundaries$reach[1]
        grid_with_reaches$grid[which(all_set)] <- grid
    } else {
        if (Logical_decreasing) {
            # Include end (right) and exclude start (left)
            for (i in 1:nrow(reach_KP_boundaries)) {
                if (i != nrow(reach_KP_boundaries)) {
                    idx_position_reaches <- which(
                        grid > reach_KP_boundaries$KP_start[i] &
                            grid <= reach_KP_boundaries$KP_end[i]
                    )
                } else {
                    idx_position_reaches <- which(
                        grid >= reach_KP_boundaries$KP_start[i] &
                            grid <= reach_KP_boundaries$KP_end[i]
                    )
                }

                grid_with_reaches$reaches[idx_position_reaches] <- reach_KP_boundaries$reach[i]
                grid_with_reaches$grid[idx_position_reaches] <- grid[idx_position_reaches]
            }
        } else {
            # Include start (left) and exclude end (right)
            for (i in 1:nrow(reach_KP_boundaries)) {
                if (i != nrow(reach_KP_boundaries)) {
                    idx_position_reaches <- which(
                        grid >= reach_KP_boundaries$KP_start[i] &
                            grid < reach_KP_boundaries$KP_end[i]
                    )
                } else {
                    idx_position_reaches <- which(
                        grid >= reach_KP_boundaries$KP_start[i] &
                            grid <= reach_KP_boundaries$KP_end[i]
                    )
                }


                grid_with_reaches$reaches[idx_position_reaches] <- reach_KP_boundaries$reach[i]
                grid_with_reaches$grid[idx_position_reaches] <- grid[idx_position_reaches]
            }
        }
    }

    if (any(is.na(grid_with_reaches))) {
        return(stop("Some values in the vector reaches have not been assigned"))
    }
    return(grid_with_reaches)
}

#####################

Input_MR <- data.frame(
    reach = c(1, 2, 3),
    KP_start = c(0, 0, 18),
    KP_end = c(18, 20, 25)
)

Input_XR <- list(
    MR = c(1, 3),
    TR = c(2)
)

Key_Info_XR_MR <- vector(mode = "list", length = length(Input_XR))
names(Key_Info_XR_MR) <- names(Input_XR)
for (i in seq_along(Key_Info_XR_MR)) {
    # Get information from MH by XR
    mask_MR_by_XR <- Input_MR[match(Input_XR[[i]], Input_MR$reach), ]
    # Input_MR[which(Input_MR$reach %in% Input_XR[[i]]), ]

    if (nrow(mask_MR_by_XR) != 1) {
        if (all(diff(mask_MR_by_XR$KP_start) < 0)) {
            Logical_decreasing <- TRUE

            mask_MR_by_XR <- mask_MR_by_XR %>%
                rename(
                    KP_start = KP_end,
                    KP_end = KP_start
                )
        } else if (all(diff(mask_MR_by_XR$KP_start) > 0)) {
            Logical_decreasing <- FALSE
        } else {
            stop("All KP_start values must be increased or decreased")
        }
    } else if (nrow(mask_MR_by_XR) == 0) {
        stop("Any matched found between MR and XR, please verify")
    } else {
        if ((mask_MR_by_XR$KP_start - mask_MR_by_XR$KP_end) < 0) {
            Logical_decreasing <- FALSE
        } else {
            Logical_decreasing <- TRUE

            mask_MR_by_XR <- mask_MR_by_XR %>%
                rename(
                    KP_start = KP_end,
                    KP_end = KP_start
                )
        }
    }


    # Get nodes of MR
    MR_nodes <- unique(c(
        mask_MR_by_XR$KP_start,
        mask_MR_by_XR$KP_end
    ))
    MR_nodes <- sort(MR_nodes, decreasing = Logical_decreasing)

    Key_Info_XR_MR[[i]]$MR_nodes <- MR_nodes

    # Grid from interpolation passing by MR_nodes
    # KP_MR_nodes is defined by XR
    KP_MR_nodes <- interpolation_specific_points(
        total_points = 100,
        specific_nodes = MR_nodes
    )

    KP_MR_nodes <- sort(KP_MR_nodes, decreasing = Logical_decreasing)

    # Assign reach at the KP_MR_nodes
    KP_reach_MR_nodes <- assign_reach_from_a_grid(
        reach_KP_boundaries = mask_MR_by_XR,
        grid = KP_MR_nodes,
        Logical_decreasing = Logical_decreasing
    )

    # These information allow build RUGFile
    if (Logical_decreasing) {
        RUGFile <- data.frame(
            id_reach = KP_reach_MR_nodes$reaches[-nrow(KP_reach_MR_nodes)],
            KP_start = KP_reach_MR_nodes$grid[-1],
            KP_end = KP_reach_MR_nodes$grid[-nrow(KP_reach_MR_nodes)],
            Kmin = 0,
            Kflood = 0
        )
    } else {
        RUGFile <- data.frame(
            id_reach = KP_reach_MR_nodes$reaches[-nrow(KP_reach_MR_nodes)],
            KP_start = KP_reach_MR_nodes$grid[-nrow(KP_reach_MR_nodes)],
            KP_end = KP_reach_MR_nodes$grid[-1],
            Kmin = 0,
            Kflood = 0
        )
    }
    Key_Info_XR_MR[[i]]$RUGFile <- RUGFile
    # Now, the middle value of each interval is taken to get the KP_grid, which will be used for all the calculations

    # Calculate the middle value for each row
    Key_Info_XR_MR[[i]]$KP_grid <- (RUGFile$KP_start + RUGFile$KP_end) / 2
    Key_Info_XR_MR[[i]]$reach <- RUGFile$id_reach
    Key_Info_XR_MR[[i]]$Logical_decreasing <- Logical_decreasing
}


##########
kmin_spat <- list(
    MR = c(35, -1.8, -0.8),
    TR = c(30, -2.5, -0.8)
)

kflood_spat <- list(
    MR = c(18),
    TR = c(18)
)

spatialisation_results <- list()
for (i in 1:length(Key_Info_XR_MR)) {
    Z <- getCovariate_Legendre(
        max_polynomial_degree = 2,
        covariate_discretization = Key_Info_XR_MR[[i]]$KP_grid
    )
    Zflood <- getCovariate_Legendre(
        max_polynomial_degree = 0,
        covariate_discretization = Key_Info_XR_MR[[i]]$KP_grid
    )

    kmin_spat_res <- Z %*% kmin_spat[[i]]
    kflood_spat_res <- Zflood %*% kflood_spat[[i]]


    plot(kmin_spat_res)
    plot(kflood_spat_res)
    spatialisation_results[[i]] <- data.frame(
        id_reach = i,
        KP_start = Key_Info_XR_MR[[i]]$RUGFile$KP_start,
        KP_end = Key_Info_XR_MR[[i]]$RUGFile$KP_end,
        Kmin = kmin_spat_res,
        Kflood = kflood_spat_res,
        K_covariate = Key_Info_XR_MR[[i]]$KP_grid
    )

    RUG_path <- paste0("/home/famendezrios/Documents/These/VSCODE-R/HydroBayes/HydroBayes_git/data/data-raw/Synthetic_case/Codes_synthetic_friction/Simplified_Rect/RUGFile_spatialized_reach", i, ".RUG")
    # RUG_path <- paste0("/home/famendezrios/Documents/These/VSCODE-R/HydroBayes/HydroBayes_git/data/data-raw/Synthetic_case/Codes_synthetic_friction/simplified/RUGFile_spatialized_reach", i, ".RUG")


    write_RUGFile(
        RUG_path = RUG_path,
        RUGFile_data = spatialisation_results[[i]],
        RUG_format = "%1s%3d      %10.3f%10.3f%10.2f%10.2f"
    )
}

RUGFile_data <- do.call(rbind, spatialisation_results)

RUG_path <- "/home/famendezrios/Documents/These/VSCODE-R/HydroBayes/HydroBayes_git/data/data-raw/Synthetic_case/Codes_synthetic_friction/Simplified_Rect/RUGFile_spatialized.RUG"
# RUG_path <- "/home/famendezrios/Documents/These/VSCODE-R/HydroBayes/HydroBayes_git/data/data-raw/Synthetic_case/Codes_synthetic_friction/simplified/RUGFile_spatialized.RUG"


write_RUGFile(
    RUG_path = RUG_path,
    RUGFile_data = RUGFile_data,
    RUG_format = "%1s%3d      %10.3f%10.3f%10.2f%10.2f"
)
